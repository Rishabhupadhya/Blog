
---

title: "Microservices Didnâ€™t Make Us Faster â€” They Made Us Slower"

date: "2026-01-29"

description: "Microservices promised speed and scalability, but for many teams they increased complexity, latency, and cost. Hereâ€™s why modular monoliths are making a comeback."

tags: ["system-design", "microservices", "modular-monolith", "backend-engineering", "architecture"]

---

> ðŸš¨ **Microservices were supposed to make teams faster.** For many teams, they did the opposite.
>
> What started as a modern architectural upgrade quietly turned into an **overâ€‘engineering trap**.
>
> This post explains **what actually went wrong**, **why modular monoliths are winning again**, and **how to choose architecture based on realityâ€”not trends**.

---

## TL;DR

- Microservices increase **operational complexity**.
- Network calls add **latency and new failure modes**.
- Debugging becomes **distributed and slower**.
- Infrastructure and observability costs rise **faster than business value**.
- Modular monoliths deliver **speed, clarity, and lower cost** for most teams.

---

## The Promise of Microservices

Microservices promised:

- Independent deployments  
- Team autonomy  
- Elastic scalability  
- Faster development

In theory, this works â€” **at massive scale with strong platform capabilities and mature DevOps**.  
Most teams donâ€™t operate there.

---

## What Actually Happened

Teams adopting microservices encountered:

- Kubernetes and container orchestration overhead  
- CI/CD pipelines *per service*  
- Service meshes, retries, timeouts, and circuit breaking  
- Distributed tracing to debug simple bugs  
- **Network calls replacing inâ€‘process function calls**

The system became harder to understand than the business logic.

---

## The Hidden Cost: Operational Drag

### 1) Operational Complexity

Every microservice adds its own:

- Build & test pipelines  
- Deployment units  
- Monitoring/alerting  
- Security policies & IAM  
- Versioning & backward compatibility

Complexity grows **multiplicatively**, not linearly.

---

### 2) Network Latency Everywhere

What used to be **function calls** becomes **remote calls** with:

- Serialization/deserialization (JSON)  
- Network latency & TLS handshakes  
- Timeouts, retries, backoff  
- Partial failures & circuit breaking

Failures are now **normal**, not exceptional.

```ts title="Function call vs network call"
// Modular monolith
const price = Pricing.calculate(items);

// Microservices
const price = await withTimeout(() => pricingService.calculate({ items }), 1000);
```

---

### 3) Debugging Slows Down

A single user request may span:

- Multiple services  
- Multiple databases  
- Queues, topics, and workers

Understanding behavior requires **dashboards and traces**, not just code & stack traces.

---

### 4) Infrastructure Cost Explosion

Each service consumes:

- Compute & memory (including idle headroom)  
- Network egress  
- Observability (logs, traces, metrics)  
- Platform overhead (service mesh, gateways)

Cost often scales **per service**, not per feature.

> Industry case studies (e.g., a Prime Video workload) reported **orderâ€‘ofâ€‘magnitude cost reductions** when consolidating a serverless microservices pipeline into a simpler, monolithic designâ€”for that specific use case.

---

## Why Modular Monoliths Are Winning Again

A **modular monolith** is *one deployable unit* with strong internal boundaries (modules/packages) and clear ownership.

Benefits:

- Inâ€‘process calls (microseconds, not milliseconds)  
- Single deployment pipeline  
- Easier debugging with stack traces  
- Simpler data consistency guarantees  
- Faster iteration for most product teams

You keep **modularity** without paying **network overhead**.

---

## Microservices vs Modular Monolith

| Dimension | Microservices | Modular Monolith |
|---|---|---|
| Communication | Remote network calls | Inâ€‘process function calls |
| Latency | Higher (ms + serialization) | Minimal (Âµs) |
| Failure Modes | Cascading across services | Mostly local |
| Debugging | Distributed tracing, dashboards | Stack traces, local logs |
| Consistency | Sagas, outbox, eventual | ACID transactions |
| Deployment | Many pipelines, versions | Single pipeline |
| Infra Cost | Higher (per service tax) | Lower |
| Best For | Org/scaling constraints | Dev speed & clarity |

---

## Architecture Flow (Highâ€‘Level)

### Microservices Request Flow

```
Client
  â†“ HTTP (TLS, latency)
API Gateway / WAF
  â†“
Service A â”€â”€â–º Service B â”€â”€â–º Service C
  â†“              â†“             â†“
 DB A           DB B          DB C
  â†“
Response (after multiple hops)
```

*Each arrow = network call + serialization + timeout + failure risk.*

---

### Modular Monolith Flow

```
Client
  â†“ HTTP
Controller â†’ Service Layer â†’ Domain Module(s) â†’ Database
  â†“
Response
```

*Each arrow = an inâ€‘process function call (except the initial HTTP and DB call).* 

---

## The Same Feature â€” Two Implementations

### Microservices (Distributed, productionâ€‘grade sketch)

```ts
// order-service/createOrder.ts
import { z } from "zod";

// Pretend helpers for resilience & observability
import { withTimeout, retry, CircuitBreaker } from "./resilience";
import { logger, metrics, getCorrelationId } from "./observability";
import { authService, pricingService, paymentService } from "./clients";
import { saveOrder } from "./orderRepo";
import { publishEvent } from "./eventBus";

const CreateOrderSchema = z.object({
  token: z.string().min(10),
  items: z.array(z.object({ sku: z.string(), qty: z.number().int().positive() })).min(1),
  idempotencyKey: z.string().min(8),
  currency: z.enum(["USD", "EUR", "INR"]).default("USD"),
});

const breaker = new CircuitBreaker({ failureThreshold: 5, resetMs: 15000 });

export async function createOrder(reqBody: unknown) {
  const start = Date.now();
  const cid = getCorrelationId();

  const { token, items, idempotencyKey, currency } = CreateOrderSchema.parse(reqBody);

  logger.info({ cid, itemsCount: items.length }, "createOrder:start");

  // 1) AuthN/AuthZ
  const user = await withTimeout(
    () => retry(() => authService.verify(token, { cid }), { retries: 2, backoffMs: 100 }),
    1200
  );

  // 2) Pricing
  const price = await withTimeout(
    () => retry(() => pricingService.calculate({ items, currency }, { cid }), { retries: 2, backoffMs: 100 }),
    1000
  );

  // 3) Payment with idempotency + breaker
  const payment = await breaker.exec(() =>
    withTimeout(
      () =>
        paymentService.charge(
          { customerId: user.sub, amount: price.total, currency },
          { idempotencyKey, cid }
        ),
      1800
    )
  );

  // 4) Persist + publish event (ideally via transactional outbox)
  const order = await saveOrder({
    userId: user.sub,
    amount: price.total,
    currency,
    paymentId: payment.id,
    items,
    cid,
  });

  await publishEvent("order.created.v1", {
    orderId: order.id,
    userId: user.sub,
    amount: price.total,
    currency,
    paymentId: payment.id,
    items,
    cid,
  });

  metrics.histogram("order.latency_ms").record(Date.now() - start);
  logger.info({ cid, orderId: order.id }, "createOrder:success");
  return { orderId: order.id };
}
```

> Key points: input validation, timeouts/retries/circuit breaking, idempotency, event publication, structured logs & metrics.

---

### Modular Monolith (Transactionally safe sketch)

```ts
// app/order/createOrder.ts
import { z } from "zod";
import { db } from "../infra/db";        // your ORM/DB adapter
import { Outbox } from "../infra/outbox"; // transactional outbox helper
import { PaymentGateway } from "../payments/PaymentGateway";
import { Auth } from "../auth/Auth";
import { logger } from "../infra/logger";

const Schema = z.object({
  userId: z.string().uuid(),
  items: z.array(z.object({ sku: z.string(), qty: z.number().int().positive() })).min(1),
  currency: z.enum(["USD", "EUR", "INR"]).default("USD"),
  idempotencyKey: z.string().min(8),
});

export async function createOrder(input: unknown) {
  const { userId, items, currency, idempotencyKey } = Schema.parse(input);

  Auth.ensureUserCanOrder(userId);

  const price = Pricing.calculate(items, currency);

  return await db.transaction(async (tx) => {
    // Enforce idempotency at the DB level
    const existing = await tx.order.findUnique({ where: { idempotencyKey } });
    if (existing) return { orderId: existing.id, reused: true };

    // Provisional row to anchor retries
    const provisional = await tx.order.create({
      data: {
        userId,
        amount: price.total,
        currency,
        status: "PAYMENT_PENDING",
        idempotencyKey,
      },
    });

    // External sideâ€‘effect
    const payment = await PaymentGateway.charge({
      customerId: userId,
      amount: price.total,
      currency,
      idempotencyKey,
    });

    await tx.order.update({
      where: { id: provisional.id },
      data: { status: "PAID", paymentId: payment.id },
    });

    await Outbox.add(tx, "order.created.v1", {
      orderId: provisional.id,
      userId,
      amount: price.total,
      currency,
      paymentId: payment.id,
      items,
    });

    logger.info({ orderId: provisional.id }, "Order created");
    return { orderId: provisional.id };
  });
}
```

> Key points: single deployable unit, ACID transaction, DBâ€‘enforced idempotency, safe handling of external sideâ€‘effects, transactional outbox for event publication.

---

## Production Checklist

- [ ] Strict input validation (types + business invariants)  
- [ ] Authentication *and* authorization  
- [ ] Timeouts, retries, backoff, and circuit breakers for remote calls  
- [ ] Idempotency keys stored & enforced serverâ€‘side  
- [ ] Structured logging with correlation/trace IDs  
- [ ] Metrics & SLOs (latency, error rate, saturation)  
- [ ] Consistency strategy: Saga/Outbox (microservices) or ACID (monolith)  
- [ ] Transaction boundaries that exclude external sideâ€‘effects  
- [ ] Compensations & reconciliation paths  
- [ ] Cost awareness: perâ€‘service tax (compute, egress, observability)

---

## Choosing Reality Over Hype

- If youâ€™re **< 10 teams** or **< a few dozen engineers**, a **modular monolith** will usually get you **faster feature velocity** and **lower cost**.  
- Adopt microservices for **organizational scaling** (team autonomy, independent lifecycles) or **hard technical constraints** (heterogeneous runtimes, regional isolation, perâ€‘domain scaling).

**Start simple, modularize hard, and split services only when the seams are obvious.**

---

## Notes

- The examples above are **sketches** to illustrate concerns and patterns, not dropâ€‘in code.  
- Every architecture has tradeâ€‘offs. The goal is **fitâ€‘forâ€‘purpose**, not purity.

