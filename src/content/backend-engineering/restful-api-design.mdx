---
title: "RESTful API Design Best Practices"
date: "Jan 2026"
description: "Learn how to design clean, scalable, and maintainable REST APIs"
---

## REST API Fundamentals

REST (Representational State Transfer) is an architectural style for designing networked applications.

### HTTP Methods

- **GET**: Retrieve resources
- **POST**: Create new resources
- **PUT**: Update existing resources
- **DELETE**: Remove resources

## Best Practices

### 1. Use Proper HTTP Status Codes

Return appropriate status codes for different scenarios.

Here's an example of a well-structured Express.js API endpoint:

```javascript
const express = require('express');
const router = express.Router();

// GET all users
router.get('/api/v1/users', async (req, res) => {
    try {
        const users = await User.find();
        res.status(200).json({
            success: true,
            data: users
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Server error'
        });
    }
});

// GET single user
router.get('/api/v1/users/:id', async (req, res) => {
    try {
        const user = await User.findById(req.params.id);
        if (!user) {
            return res.status(404).json({
                success: false,
                message: 'User not found'
            });
        }
        res.status(200).json({
            success: true,
            data: user
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Server error'
        });
    }
});

module.exports = router;
```

### 2. Versioning

Implement API versioning for backward compatibility.

```python
from flask import Flask, jsonify
from flask_restful import Api, Resource

app = Flask(__name__)
api_v1 = Api(app, prefix='/api/v1')
api_v2 = Api(app, prefix='/api/v2')

class UserListV1(Resource):
    def get(self):
        return jsonify({
            'version': '1.0',
            'users': [
                {'id': 1, 'name': 'John'},
                {'id': 2, 'name': 'Jane'}
            ]
        })

class UserListV2(Resource):
    def get(self):
        return jsonify({
            'version': '2.0',
            'data': {
                'users': [
                    {'id': 1, 'name': 'John', 'email': 'john@example.com'},
                    {'id': 2, 'name': 'Jane', 'email': 'jane@example.com'}
                ],
                'total': 2
            }
        })

api_v1.add_resource(UserListV1, '/users')
api_v2.add_resource(UserListV2, '/users')
```

### 3. Authentication & Security

Use OAuth 2.0, JWT tokens, and HTTPS for secure APIs.

```typescript
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';

interface JWTPayload {
    userId: string;
    email: string;
}

// Generate JWT token
export const generateToken = (userId: string, email: string): string => {
    return jwt.sign(
        { userId, email },
        process.env.JWT_SECRET!,
        { expiresIn: '7d' }
    );
};

// Middleware to verify JWT
export const authenticate = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        const token = req.headers.authorization?.split(' ')[1];
        
        if (!token) {
            return res.status(401).json({
                message: 'Authentication required'
            });
        }
        
        const decoded = jwt.verify(
            token,
            process.env.JWT_SECRET!
        ) as JWTPayload;
        
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({
            message: 'Invalid or expired token'
        });
    }
};
```
